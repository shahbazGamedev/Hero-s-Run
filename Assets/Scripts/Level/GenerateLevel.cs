using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public enum SegmentTheme {
		Forest = 0,
		Fairyland = 1,
		Cemetery = 2,
		Dark_Tower = 6,
		Jungle = 7,
		Blizzard = 10,
		Caves = 11,
		Hell = 12,
		Dragon_Lair = 13,
		Jousting = 14,
		Desert = 15
}

public sealed class GenerateLevel  : MonoBehaviour {
	
	private LevelData levelData;
	[SerializeField] GameObject singlePlayerHeroPrefab;
	[SerializeField] GameObject singlePlayerTrollPrefab;
	[SerializeField] GameObject singlePlayerFairyPrefab;
	const float TILE_SIZE_CAMPAIGN = 36.4f;
	public static float tileSize;
	const float UNDERNEATH_TILE_BY = 12f;
	int tileDepthMult = 1; //A value of one means the tile depth is 1 x TILE_SIZE, a value of two means 2 x TILE_SIZE, etc.
	
	//worldRoadSegments is a List of game object tiles
	List<GameObject> worldRoadSegments = new List<GameObject>(300);

	//tileCreationIndex is incremented each time a new tile is added.
	//It is also used to control the power up density as we add a power up every 'X' tiles.
	//Lastly it is appended at the name of every tile created to facilitate debugging.
	int tileCreationIndex = 0;

	Vector3 previousTilePos = new Vector3( 0,0,0 );
	Quaternion previousTileRot = Quaternion.identity;
	TileSubType previousTileType = TileSubType.None;

	//This number is used to make sure that the subsequent tiles are at the proper height.
	float  tileEndHeight = 0;

	//The number of visible tiles at any given time (all other tiles are deactivated).
	int nbrVisibleTiles = 3;
	
	//For adding power-ups in tiles
	public PowerUpManager powerUpManager;
	public TileGroupManager tileGroupManager;
	[SerializeField] LevelNetworkingManager levelNetworkingManager;
	
	SegmentTheme currentTheme;
	
	//The surrounding plane (like an ocean) is always centered with the current tile
	public Transform surroundingPlane;
	
	//To improve performance by preloading prefabs and avoiding reloading tile prefabs that have previously been loaded.
	const int NUMBER_OF_THEMES = 8; //Dark Tower, Forest, Fairyland, Cemetery, etc.
	Dictionary<SegmentTheme,Dictionary<TileType,GameObject>> tilePrefabsPerTheme  = new Dictionary<SegmentTheme,Dictionary<TileType,GameObject>>(NUMBER_OF_THEMES);

	//For the endless running game mode
	Queue<TileType> endlessTileList = new Queue<TileType>();
	TileGroupType previousRandomTileGroupType = TileGroupType.None;

	//For the Episode Progress Indicator - to know where to display the checkpoint indicators
	List<int> indexOfCheckpointTiles = new List<int>();

	public float levelLengthInMeters = 0;
	int seed = 0; //Random generator seed to use when online.

	void Awake ()
	{
		//The activity indicator may have been started
		Handheld.StopActivityIndicator();

		levelData = LevelManager.Instance.getLevelData();

		//In order to configure the zombie waves, a Tile Holder game object containing the entire zombie map exists in the Level scene.
		//We do not need it during runtime. This is just used for editing purposes.
		//Delete this object if it exists to save memory.
		GameObject tileHolder = GameObject.Find("Tile Holder");
		if( tileHolder != null ) Destroy( tileHolder );

		//In multiplayer games, we want all the players to have the same results when using the random generator. This is why we seed it.
		//The seed is set by the master when the room is created.
		//When playing offline, the room generated by Photon will not have custom properties.
		//This is why we make sure it is not null.
		ExitGames.Client.Photon.Hashtable customRoomProperties = PhotonNetwork.room.CustomProperties;
		if( customRoomProperties != null )
		{
			if( customRoomProperties.ContainsKey("Seed") )
			{
				seed = (int) PhotonNetwork.room.CustomProperties["Seed"];
				Debug.Log("Random seed " + seed );
				Random.InitState( seed );
			}
			else
			{
				Debug.Log("customRoomProperties does not contain the key 'Seed'." );
			}
			if( customRoomProperties.ContainsKey("Map") )
			{
				string mapName = PhotonNetwork.room.CustomProperties["Map"].ToString();
				Debug.Log("GenerateLevel Awake Map " + mapName );
				LevelData.MultiplayerInfo mi = levelData.getMapByName( mapName );
				LevelManager.Instance.setSelectedCircuit( mi );
			}
			else
			{
				Debug.Log("customRoomProperties does not contain the key 'Map'." );
			}
		}
		else
		{
			Debug.Log("customRoomProperties is null" );
		}

		if( GameManager.Instance.isMultiplayer() )
		{
			createMultiplayerLevel ();
		}
		else
		{
			createSinglePlayerLevel ();
		}
	}

	private void loadTilePrefabs( SegmentTheme theme )
	{
		//Don't bother reloading the prefabs if they have already been loaded
		if( tilePrefabsPerTheme.ContainsKey(theme) ) return;

		GameObject go;

		//Load tile prefabs from the specified theme folder
		Object[] themePrefabs = Resources.LoadAll("Level/Tiles/" + theme.ToString() + "/", typeof(GameObject));
		Dictionary<TileType,GameObject> themePrefabsDict = new Dictionary<TileType,GameObject>(themePrefabs.Length);

		//Copy to dictionary
		for(int i = 0; i < themePrefabs.Length; i++ )
		{
			go = (GameObject)themePrefabs[i];
			SegmentInfo si = getSegmentInfo( go );
			if( si.tileType != TileType.None )
			{
				//Debug.Log ("loadTilePrefabs-adding tile type: " + si.tileType );
				themePrefabsDict.Add( si.tileType, go );
			}
		}
		tilePrefabsPerTheme.Add(theme, themePrefabsDict);

	}

	private void createSinglePlayerLevel ()
	{
		//Reset values
		worldRoadSegments.Clear();
		tileCreationIndex = 0;
		tileSize = TILE_SIZE_CAMPAIGN;
						
		LevelData.EpisodeInfo currentEpisode = LevelManager.Instance.getCurrentEpisodeInfo();

		//Sets the skybox, the directional light intensity and direction for the current episode
		levelData.initialise();
		levelData.setSunParameters(currentEpisode.sunType);

		//Verify if we should include a plane surrounding the tiles (like an ocean)
		if( currentEpisode.includeSurroundingPlane )
		{
			GameObject go = (GameObject)Instantiate(surroundingPlane.gameObject, new Vector3( 0, -UNDERNEATH_TILE_BY, 0 ), Quaternion.identity );
			surroundingPlane = go.transform;
			if( surroundingPlane.GetComponent<Renderer>().material != null )
			{
				surroundingPlane.GetComponent<Renderer>().material = currentEpisode.surroundingPlaneMaterial;
				surroundingPlane.gameObject.SetActive( true );
			}
			else
			{
				Debug.LogWarning("GenerateLevel-CreateLevel: includeSurroundingPlane is set to true but no surroundingPlaneMaterial has been specified.");
			}
		}
		else
		{
			surroundingPlane.gameObject.SetActive( false );
		}

		List<TileGroupType> tileGroupList = currentEpisode.tileGroupList;

		if( GameManager.Instance.getGameMode() == GameMode.Story )
		{
			generateStoryLevel( tileGroupList );
		}
		else
		{
			generateEndlessLevel( tileGroupList );
		}

		deactivateTiles();

		//Configure fog, if any
		Camera.main.GetComponent<DynamicFogAndMist.DynamicFog>().enabled = currentEpisode.isFogEnabled;
		if( currentEpisode.isFogEnabled ) levelData.setFogParameters(currentEpisode.sunType);

		//Create the Troll because he does not exist in the level scene. The troll is not used in multiplayer.
		GameObject troll = (GameObject)Instantiate( singlePlayerTrollPrefab );

		//Create the Fairy because she does not exist in the level scene. The fairy is not used in multiplayer.
		GameObject fairy = (GameObject)Instantiate( singlePlayerFairyPrefab );

		//Create the Hero because he does not exist in the level scene
		GameObject hero = (GameObject)Instantiate( singlePlayerHeroPrefab );

		//The player needs to have a reference to the troll and fairy
		hero.GetComponent<PlayerController>().setTrollController( troll.GetComponent<TrollController>() );
		hero.GetComponent<PlayerController>().setFairyController( fairy.GetComponent<FairyController>() );

		Debug.Log("GenerateLevel-CreateLevel: Level " + currentEpisode.episodeName + " has been created." );
	}

	private void generateStoryLevel( List<TileGroupType> tileGroupList )
	{
		int numbersOfCheckpointsPassed = LevelManager.Instance.getNumberOfCheckpointsPassed();
		int episodeCheckpointIndex = 0;
		for( int i=0; i < tileGroupList.Count; i++ )
		{
			TileGroup tg = tileGroupManager.getTileGroup(tileGroupList[i]);
			if( isTileGroupACheckpoint( tg ) )
			{
				episodeCheckpointIndex++;
			}
			if( numbersOfCheckpointsPassed > episodeCheckpointIndex ) continue; //we want to restart at the last passed checkpoint, not from the Start tile
			if( tg.frequency != TileGroup.FrequencyType.Never && (tg.validGameMode == ValidGameMode.Any || tg.validGameMode == ValidGameMode.Story) )
			{
				setCurrentTheme(tg.theme );
				List<TileType> individualTiles = tg.tileList;
				for( int j=0; j < individualTiles.Count; j++ )
				{
					if( individualTiles[j] == TileType.Checkpoint )
					{
						indexOfCheckpointTiles.Add( tileCreationIndex );
					}
					addTile( individualTiles[j] );
				}
			}
		}
		worldRoadSegments.TrimExcess();		
	}

	private bool isTileGroupACheckpoint( TileGroup tg )
	{
		if( tg.tileGroupType == TileGroupType.Blizzard_Checkpoint || tg.tileGroupType == TileGroupType.Cemetery_Checkpoint
			|| tg.tileGroupType == TileGroupType.Fairyland_Checkpoint || tg.tileGroupType == TileGroupType.Jungle_Checkpoint
			|| tg.tileGroupType == TileGroupType.Mines_Checkpoint || tg.tileGroupType == TileGroupType.Tanglewood_Checkpoint
			|| tg.tileGroupType == TileGroupType.Hell_Checkpoint )
		{
			return true;
		}
		{
			return false;
		}
	}

	private void generateEndlessLevel( List<TileGroupType> tileGroupList )
	{
		//the first tile group needs to have the Start tile and 3 others
		TileGroup tg = tileGroupManager.getTileGroup(tileGroupList[0]);
		if( tg.validGameMode == ValidGameMode.Any || tg.validGameMode == ValidGameMode.Endless )
		{
			setCurrentTheme(tg.theme );

			List<TileType> individualTiles = tg.tileList;
			for( int j=0; j < individualTiles.Count; j++ )
			{
				addTile( individualTiles[j] );
			}
		}
		//Now add a first random tile group to the endless tiles Queue
		addRandomTileGroupToEndlessTilesQueue();
	}

	private void createMultiplayerLevel ()
	{
		//Reset values
		worldRoadSegments.Clear();
		tileCreationIndex = 0;

		Debug.Log("GenerateLevel-createMultiplayerLevel: selected level is: " + LevelManager.Instance.getSelectedCircuit().circuitInfo.mapName );
						
		LevelData.MultiplayerInfo currentMultiplayer = LevelManager.Instance.getSelectedCircuit();
		if( currentMultiplayer.tileSize == 0 ) Debug.LogError("GenerateLevel error: the tile size for this level is 0. You must set the tile size in MultiplayerInfo. See LevelData.");
		tileSize = currentMultiplayer.tileSize;

		//Sets the skybox, the directional light intensity and direction for the current episode
		levelData.initialise();
		levelData.setSunParameters(currentMultiplayer.sunType);

		//Verify if we should include a plane surrounding the tiles (like an ocean)
		if( currentMultiplayer.includeSurroundingPlane )
		{
			GameObject go = (GameObject)Instantiate(surroundingPlane.gameObject, new Vector3( 0, -UNDERNEATH_TILE_BY, 0 ), Quaternion.identity );
			surroundingPlane = go.transform;
			if( surroundingPlane.GetComponent<Renderer>().material != null )
			{
				surroundingPlane.GetComponent<Renderer>().material = currentMultiplayer.surroundingPlaneMaterial;
				surroundingPlane.gameObject.SetActive( true );
			}
			else
			{
				Debug.LogWarning("GenerateLevel-CreateLevel: includeSurroundingPlane is set to true but no surroundingPlaneMaterial has been specified.");
			}
		}
		else
		{
			surroundingPlane.gameObject.SetActive( false );
		}

		GameObject wsmgo = GameObject.FindGameObjectWithTag("World Sound Manager");
		WorldSoundManager wsm = null;
		if( wsmgo != null )
		{
			wsm = wsmgo.GetComponent<WorldSoundManager>();
		}
		else
		{
			Debug.LogError("GenerateLevel error-can't locate game object with the tag 'World Sound Manager' in the Level scene.");
		}

		//See if it can rain in the level.
		if( currentMultiplayer.rainChance > 0 )
		{
			//It rains randomly ...
			if( Random.value <= currentMultiplayer.rainChance )
			{
				//Yes, it is raining.
				//Decide between Light rain and Heavy rain.
				LevelManager.Instance.rainType = (RainType) Random.Range( 1, 3 );

				//Get the rain audio clip and play it as an ambience track.
				if( currentMultiplayer.rainAudio != null )
				{
					wsm.mainAmbienceAudioSource.clip = currentMultiplayer.rainAudio;
				}
				else
				{
					Debug.LogWarning("GenerateLevel warning-the level has rain, but no rain audio clip is specified.");
				}
			}
			else
			{
				//It's not raining this time.
				LevelManager.Instance.rainType = RainType.No_Rain;
			}
		}
		else
		{
			//It doesn't rain in this level.
			LevelManager.Instance.rainType = RainType.No_Rain;
		}
		StartCoroutine( wsm.crossFadeToMainAmbience( 3f ) );

		generateMultiplayerLevel( currentMultiplayer.numberOfTileGroups, currentMultiplayer.tileGroupList, currentMultiplayer.endTileGroupList  );

		//Adjust the length of the level
		//When we added the length of the Start tile, we added its full length. However, the player starts in the center of the Start tile. So we added 50 - 25 = 25 meters too much.
		levelLengthInMeters = levelLengthInMeters - 25f;
		//When we added the length of the End tile, we added its full length. However, the finish line is located at 28.9 meters. So we added 50 - 29.3 = 20.7 meters too much.
		levelLengthInMeters = levelLengthInMeters - 20.7f;

		//Some game objects have a random activator component. You need to call this method BEFORE deactivateTiles.
		enableRandomActivators();

		//To help performance, deactivate all the tiles except the first ones.
		deactivateTiles();

		//Configure fog, if any
		Camera.main.GetComponent<DynamicFogAndMist.DynamicFog>().enabled = currentMultiplayer.isFogEnabled;
		if( currentMultiplayer.isFogEnabled ) levelData.setFogParameters(currentMultiplayer.sunType);

		Debug.Log("GenerateLevel-CreateLevel: Level " + currentMultiplayer.circuitInfo.mapName + " has been created." );

	}

	/// <summary>
	/// Fetches all game objects with a RandomActivator component and decides whether that game object should be active or not.
	/// RandomActivator is used on tile game objects to make sure that all tile instances don't look the same.
	/// For example, you can have a tree cluster on a Straight tile. With a random activator, the cluster will only appear on a Straight tile when the random number generated 
	/// is less or equal than the chanceDisplayed number.
	/// RamdomActivator works in multiplayer. If an object is active on one device, the same object is guaranteed to be active on all other devices.
	/// </summary>
	void enableRandomActivators()
	{
		//Seed the random generator so that we have consistent results across all devices.
		if( GameManager.Instance.isOnlinePlayMode() ) Random.InitState( seed );

		RandomActivator[] randomActivators = GameObject.FindObjectsOfType<RandomActivator>();
		int isActiveCount = 0; //for debugging
		for( int i = 0; i < randomActivators.Length; i++ )
		{
			if( Random.value <= randomActivators[i].chanceDisplayed )
			{
				//We want it active
				randomActivators[i].gameObject.SetActive( true );
				isActiveCount++;
			}
			else
			{
				//We want it inactive
				randomActivators[i].gameObject.SetActive( false );
			}
		}
		Debug.Log("GenerateLevel-enableRandomActivators: there are " + randomActivators.Length + " activators in the scene and the number activated was " + isActiveCount + ". The seed used was " + seed );	
	}

	//Note that the level is generated in two steps:
	//Step one creates a list of TileGroupType stored in multiplayerTileGroupList.
	//Step two then takes that list and generates the individual tiles.
	//Why are we doing this?
	//A level may contain random tiles.
	//We want the master client to create the official tile group list and send it to the other players so that everyone sees the same level.
	//Sending the tile group list to the other players is NOT coded yet.
	private void generateMultiplayerLevel( int numberOfTileGroups, List<TileGroupType> tileGroupList, List<TileGroupType> endTileGroupList )
	{
		List<TileGroupType> multiplayerTileGroupList = new List<TileGroupType>();

		//First, add the preset tile groups from tileGroupList
		for( int i=0; i < tileGroupList.Count; i++ )
		{
			multiplayerTileGroupList.Add( tileGroupManager.getTileGroup(tileGroupList[i]).tileGroupType );
		}

		//Second, calculate how many additional random tile groups we need to reach the desired number of tile groups.
		//We substract one because we always add an end tile group.
		//We will use the same theme as the Start tile for the random tiles.
		TileGroup startTileGroup = tileGroupManager.getTileGroup(multiplayerTileGroupList[0]);
		setCurrentTheme( startTileGroup.theme );

		int additionalTileGroupsNeeded = numberOfTileGroups - tileGroupList.Count - 1;

		if( additionalTileGroupsNeeded > 0 )
		{
			//Third, populate the rest of the level with random tile groups.
			for( int i=0; i < additionalTileGroupsNeeded; i++ )
			{
				TileGroup rtg = tileGroupManager.getRandomTileGroup( currentTheme );
				//Try to avoid having two identical tile groups back to back if possible.
				//We will make one attempt to change it if it is identical.
				if( rtg.tileGroupType == previousRandomTileGroupType ) rtg = tileGroupManager.getRandomTileGroup( currentTheme );
				previousRandomTileGroupType = rtg.tileGroupType;
				multiplayerTileGroupList.Add( rtg.tileGroupType );
			}
		}

		//Fourth, add one random End tile.
		if( endTileGroupList.Count > 0 )
		{
			int random = Random.Range(0, endTileGroupList.Count );
			TileGroupType etgt = endTileGroupList[random];
			multiplayerTileGroupList.Add( etgt );
		}
		else
		{
			Debug.LogError("GenerateLevel: Error while generating multiplayer level. The endTileGroupList is empty. It must contain at least one tile.");
		}

		//Five, create the individual tiles
 		addTileGroups( multiplayerTileGroupList );
	}

	private void addTileGroups( List<TileGroupType> tileGroupList )
	{
		for( int i=0; i < tileGroupList.Count; i++ )
		{
			TileGroup tg = tileGroupManager.getTileGroup(tileGroupList[i]);
			//print("addTileGroups " + tg.tileGroupType );
			addTileGroup( tg );
		}
		
		worldRoadSegments.TrimExcess();		
	}

	private void addTileGroup( TileGroup tg )
	{
		setCurrentTheme(tg.theme );
		List <TileType> tiles = tg.tileList;
		for( int j=0; j < tiles.Count; j++ )
		{
			addTile( tiles[j] );
		}
	}

	private void addRandomTileGroupToEndlessTilesQueue()
	{
		TileGroup rtg = tileGroupManager.getRandomTileGroup( currentTheme );
		//Try to avoid having two identical tile groups back to back if possible.
		//We will make one attempt to change it if it is identical.
		if( rtg.tileGroupType == previousRandomTileGroupType ) rtg = tileGroupManager.getRandomTileGroup( currentTheme );
		previousRandomTileGroupType = rtg.tileGroupType;
		List <TileType> tiles = rtg.tileList;
		for( int j=0; j < tiles.Count; j++ )
		{
			endlessTileList.Enqueue(tiles[j]);
		}
	}

	//The player controller needs info about the tile the player is on.
	//This is normally set each time the player crosses an Entrance trigger.
	//However:
	//they are no Entrance in a Start tile and
	//when a player starts the game at a checkpoint, the player will be positioned in the center of the tile and therefore not cross the Entrance trigger for that tile.
	//Because of that, we simply use the info from the first tile (the one with index 0) in worldRoadSegments.
	public void setFirstTileInfoInPlayer( PlayerController playerController )
	{
		GameObject firstTile = worldRoadSegments[0];
		playerController.currentTile = firstTile;
		playerController.tileRotationY = firstTile.transform.eulerAngles.y;
		playerController.currentTilePos = firstTile.transform.position;
		SegmentInfo si = getSegmentInfo( firstTile );
		playerController.currentTileType = si.tileType;
	}

	public GameObject getFirstTile()
	{
		return worldRoadSegments[0];
	}

	private void setCurrentTheme( SegmentTheme newTheme )
	{
		currentTheme = newTheme;
	}

	private GameObject addTile ( TileType type )
	{
		GameObject go = null;
		GameObject prefab = null;
		Quaternion tileRot = Quaternion.identity;
		Vector3 tilePos = Vector3.zero;

		//Instantiate the prefab
		if( !tilePrefabsPerTheme.ContainsKey(currentTheme) ) loadTilePrefabs( currentTheme );

		Dictionary<TileType,GameObject> tilePrefabs = tilePrefabsPerTheme[currentTheme];
		if( tilePrefabs == null ) Debug.LogError("addTile: tilePrefabsPerTheme does not contain entries for theme " + currentTheme );
		if( tilePrefabs.ContainsKey(type) )
		{
			prefab = tilePrefabs[type];
		}
		else
		{
			Debug.LogError("addTile: could not find prefab for the tile type: " + type + " in the current theme " + currentTheme + " folder." );
		}

		go = (GameObject)Instantiate(prefab);
		go.name = type.ToString() + " " + tileCreationIndex.ToString();
		SegmentInfo si = getSegmentInfo( go );
		tileRot = getTileRotation();
		tilePos = getTilePosition();
		go.transform.SetPositionAndRotation( tilePos, tileRot );
		tileDepthMult= si.tileDepth;
		previousTileType = si.tileSubType; //for constructing the level, we use the simpler types like straight, left and right
		tileEndHeight = si.tileEndHeight;
		previousTilePos = tilePos;
		previousTileRot = tileRot;
		if( !GameManager.Instance.isMultiplayer() ) powerUpManager.considerAddingPowerUp( go, tileCreationIndex );
		worldRoadSegments.Add( go );
		si.tileIndex = tileCreationIndex;
		tileCreationIndex++;
		//Only register a tile for the mini-map if the tile sprite is not null or else there will be white squares on the mini-map. 
		if( si.tileSprite != null ) MiniMap.Instance.registerTileObject( go.name, go.transform.position, si.tileSprite, go.transform.eulerAngles.y, tileDepthMult );
		//Update the length of the map in meters
		levelLengthInMeters = levelLengthInMeters + tileDepthMult * tileSize;
		return go;
	}

	private Vector3 getTilePosition()
	{
		Vector3 tilePos = Vector3.zero;
		float previousTileRotY = Mathf.Floor( previousTileRot.eulerAngles.y );
		float tileDepth =  tileDepthMult * tileSize;
		//Determine the tile's height.
		float tileHeight = tileEndHeight + previousTilePos.y;
		switch (previousTileType)
		{
			case TileSubType.Straight:
			if( previousTileRotY == 0 )
			{
				tilePos.Set ( previousTilePos.x, tileHeight, previousTilePos.z + tileDepth );
			}
			else if( previousTileRotY == 270f || previousTileRotY == -90f )
			{
				tilePos.Set ( previousTilePos.x - tileDepth, tileHeight, previousTilePos.z );				
			}
			else
			{
				tilePos.Set ( previousTilePos.x + tileDepth, tileHeight, previousTilePos.z  );				
			}
			return tilePos;
	
	        case TileSubType.Left:
			if( previousTileRotY == 0 )
			{
				tilePos.Set ( previousTilePos.x - tileDepth, tileHeight, previousTilePos.z );
			}
			else if( previousTileRotY == 270f || previousTileRotY == -90f )
			{
				tilePos.Set ( previousTilePos.x , tileHeight, previousTilePos.z - tileDepth );				
			}
			else
			{
				tilePos.Set ( previousTilePos.x, tileHeight, previousTilePos.z + tileDepth );				
			}
			return tilePos;
		
			case TileSubType.Right:
			if( previousTileRotY == 0 )
			{
				tilePos.Set ( previousTilePos.x + tileDepth, tileHeight, previousTilePos.z );
			}
			else if( previousTileRotY == 270f || previousTileRotY == -90f )
			{
				tilePos.Set ( previousTilePos.x , tileHeight, previousTilePos.z + tileDepth );				
			}
			else
			{
				tilePos.Set ( previousTilePos.x, tileHeight, previousTilePos.z - tileDepth );				
			}
			return tilePos;
			
	        default:
			tilePos.Set( 0,0,0 );
            return tilePos;
		}
	}

	private Quaternion getTileRotation()
	{
		float previousTileRotY = Mathf.Floor( previousTileRot.eulerAngles.y );
		Quaternion tileRot = Quaternion.identity;
		switch (previousTileType)
		{
			case TileSubType.None:
			return Quaternion.identity;
		
			case TileSubType.Straight:
			tileRot =  Quaternion.Euler( 0, previousTileRot.eulerAngles.y, 0 );
			return tileRot;

			case TileSubType.Left:
			if( previousTileRotY == 0 )
			{
				tileRot =  Quaternion.Euler(0, -90f, 0);
			}
			else if( previousTileRotY == 270f || previousTileRotY == -90f )
			{
				tileRot =  Quaternion.Euler( 0, 0, 0 );
			}
			else
			{
				tileRot =  Quaternion.Euler( 0, 0, 0 );
			}
			return tileRot;
		
			case TileSubType.Right:
			if( previousTileRotY == 0 )
			{
				tileRot =  Quaternion.Euler( 0, 90f, 0 );
			}
			else if( previousTileRotY == 270f || previousTileRotY == -90f )
			{
				tileRot =  Quaternion.Euler( 0, 0, 0 );
			}
			else
			{
				tileRot =  Quaternion.Euler( 0, 0, 0 );
			}
			return tileRot;
			
	        default:
			Debug.LogError ("getTileRotation : unhandled tile type: " + previousTileType );
			tileRot.eulerAngles = Vector3.zero;
			return tileRot;
		}
	}

	public void enableSurroundingPlane( bool enable )
	{
		if( surroundingPlane != null ) surroundingPlane.gameObject.SetActive( enable );
	}
	
	private SegmentInfo getSegmentInfo( GameObject tile )
	{
		SegmentInfo si = tile.GetComponent<SegmentInfo>();
		if( si != null )
		{
			return si;
		}
		else
		{
			Debug.LogError("GenerateLevel-getSegmentInfo: tile named " + tile.name + " does not have a SegmentInfo component attached to it.");
			return null;
		}
	}

	void addTileInEndlessMode()
	{
		if( endlessTileList.Count > 0 )
		{
			//Yes, we still have tiles in the queue
			addTile( endlessTileList.Dequeue() );
		}
		else
		{
			//We have run out of tiles. Add a random tile group.
			addRandomTileGroupToEndlessTilesQueue();
			//Now that we have added additional tiles, we can get one
			addTile( endlessTileList.Dequeue() );
		}
	}

	public void tileEntranceCrossed( Transform currentTile  )
	{
		SegmentInfo si = getSegmentInfo( currentTile.gameObject );

		//If in endless mode, each time we enter a new tile, add a new tile at the end
		if( GameManager.Instance.getGameMode() == GameMode.Endless && !si.wasTileAdded )
		{
			si.wasTileAdded = true;
			//Add a tile at the end
			addTileInEndlessMode();
		}

		//Center the surrounding plane around the current tile
		if( surroundingPlane != null )
		{
			surroundingPlane.position = new Vector3( currentTile.position.x, currentTile.position.y -UNDERNEATH_TILE_BY, currentTile.position.z );
		}
		activateNextTile( si.tileIndex );
			
	}
	
	/// <summary>
	/// Deactivates all the tiles starting at nbrVisibleTiles + 1.
	/// This is done on game start to help with performance.
	/// </summary>
	private void deactivateTiles()
	{
		for( int i= nbrVisibleTiles + 1; i < worldRoadSegments.Count; i++ )
		{
			worldRoadSegments[i].SetActive( false );
		}
	}

	/// <summary>
	/// Activates the last 5 tiles of the level (this includes the End tile).
	/// </summary>
	public void activateTilesForCamera()
	{
		int startIndex = worldRoadSegments.Count - 5;
		if( startIndex < 0 ) startIndex = 0;
		for( int i = startIndex; i < worldRoadSegments.Count; i++ )
		{
			worldRoadSegments[i].SetActive( true );
		}
	}

	/// <summary>
	/// Deactivates the tile with an index of currentTileIndex - two.
	/// </summary>
	/// <param name="currentTileIndex">Current tile index.</param>
	public void deactivatePreviousTile( int currentTileIndex )
	{
		int indexOfTileToDeactivate = currentTileIndex - 2;
		if( indexOfTileToDeactivate >= 0 ) worldRoadSegments[indexOfTileToDeactivate].SetActive( false );
	}

	/// <summary>
	/// Activates the next tile.
	/// This would be the tile with this index: tileIndex + nbrVisibleTiles.
	/// At any given time, there are 5 active tiles (assuming nbrVisibleTiles is equal to 3):
	/// The current tile
	/// The preceding tile
	/// The 3 tiles that come after the current tile
	/// </summary>
	/// <param name="tileIndex">Index of the tile just entered by the player.</param>
	private void activateNextTile( int tileIndex )
	{
		int indexOfTileToActivate = tileIndex + nbrVisibleTiles;
		
		if( indexOfTileToActivate < worldRoadSegments.Count )
		{
			if( !worldRoadSegments[indexOfTileToActivate].activeSelf ) worldRoadSegments[indexOfTileToActivate].SetActive(true);
		}
	}

	/// <summary>
	/// Activates the next nbrVisibleTiles tiles excluding tileIndex.
	/// </summary>
	/// <param name="tileIndex">Tile index.</param>
	public void activeNextTiles( int tileIndex )
	{
		int endIndex = Mathf.Min( tileIndex + 1 + nbrVisibleTiles, worldRoadSegments.Count );
		for( int i = tileIndex + 1; i < endIndex; i++ )
		{
			if( !worldRoadSegments[i].activeSelf ) worldRoadSegments[i].SetActive(true);
		}
	}

	TileType getTileType( GameObject tile )
	{
		return getSegmentInfo(tile).tileType;
	}

	public List<int> getIndexOfCheckpointTiles()
	{
		return indexOfCheckpointTiles;
	}

	public int getNumberOfTiles()
	{
		return tileCreationIndex - 1;
	}
	
	/// <summary>
	/// Return the length of all of the tiles up to (but excluding) tileIndex.
	/// Expected behavior: 
	/// If you pass a tileIndex of 0, the value will be 0.
	/// If you pass a tileIndex of 1, assuming the first tile is the Start tile, the value will be 25.
	/// If you pass a tileIndex of 2, assuming the first tile is the Start tile and the subsequent tile is of double length, the value will be 125.
	/// Etc.
	/// </summary>
	/// <returns>The length of all of the tiles up to (but excluding) tileIndex.</returns>
	/// <param name="tileIndex">Tile index.</param>
	public float getLevelLength( int tileIndex )
	{
		float levelLength = 0;
		for( int i = 1; i <= tileIndex; i++ )
		{
			SegmentInfo si = worldRoadSegments[i-1].GetComponent<SegmentInfo>(); //we want the previous tile, hence the -1.
			if( si.tileType == TileType.Start )
			{
				//The player starts in the center of the Start tile. That's why we're multiplying by 0.5f.
				levelLength = levelLength + tileSize * 0.5f;
			}
			else
			{
				levelLength = levelLength + tileSize * si.tileDepth;
			}
		}
		return levelLength;
	}
}
